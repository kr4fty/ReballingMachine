#include <Arduino.h>
#include "config.h"
#include <PID_v1.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <max6675.h>
#include <AiEsp32RotaryEncoder.h>

AiEsp32RotaryEncoder encoder = AiEsp32RotaryEncoder(ENCODER_PIN_A, ENCODER_PIN_B, BUTTON, ENCODER_VCC_PIN, ENCODER_STEPS);
void IRAM_ATTR readEncoderISR(){
	encoder.readEncoder_ISR();
}
static unsigned long lastTimePressed = 0;
long int encoderCounter=110, oldEncoderCounter=-1;

#ifdef ZC_INTERRUPT_FILTER
  uint32_t zcNextTime=0;
#endif
uint32_t nextTime; 
uint64_t pulseOn, pulseOff, pulseDelay=0;
bool zcFlag=false, pulseFlag=false, pulseStatus;
long int zcCounter=0;
double pulseDelayTransformed;

void IRAM_ATTR zc_isr() {
  // Filtro para falsos positivos
  #ifdef ZC_INTERRUPT_FILTER
  if(!zcFlag){
    zcFlag = true;
    zcNextTime=millis()+WINDOW_INTERRUPT;
    pulseFlag = true;
    pulseOn = micros()+pulseDelay+ZC_PULSE_WIDTH/2;
  }
  #else
    zcCounter++;
    pulseFlag = true;
    pulseOn = micros()+pulseDelay+ZC_PULSE_WIDTH/2;
  #endif
}

Adafruit_ST7735 lcd = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);

MAX6675 thermocouple1(TH1_CS);  // Heater
MAX6675 thermocouple2(TH2_CS);  // Board

#define WindowSize 200
unsigned long windowStartTime;
//DEBUG
#ifdef DEBUG
unsigned long startTime;
#endif
double oldInput1=0, oldInput2=0;
#ifdef ALPHA
double InputFiltered1, InputFiltered2;
#endif

double Setpoint1, Input1, Output1;
double Setpoint2, Input2, Output2;
PID myPID = PID(&Input1, &Output1, &Setpoint1, Kp, Ki, Kd, DIRECT);

float perfilRamp;
uint16_t tiempo;
uint64_t time34Init;
uint8_t etapa=1;
 
// the setup function runs once when you press reset or power the board
void setup() {
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(BUTTON, INPUT_PULLUP);
  pinMode(ZC_PIN, INPUT);

  digitalWrite(RELAY_PIN,LOW);

  //Setpoint1 = 120;
  //turn the PID on
  myPID.SetSampleTime(WindowSize);
  myPID.SetOutputLimits(0, ZC_MAX_ANGLE);
  myPID.SetMode(AUTOMATIC);

   // Use this initializer if using a 1.8" TFT screen:
  lcd.initR(INITR_BLACKTAB);      // Init ST7735S chip, black tab
  lcd.setTextColor(ST77XX_WHITE, ST77XX_BLACK); // Para sobre escribir puntos
  lcd.fillScreen(ST77XX_BLACK);
  lcd.setRotation(1);
  lcd.setTextSize(MIDLE_TEXT);
  lcd.setCursor(0*6*MIDLE_TEXT, 3*8*MIDLE_TEXT);
  lcd.setTextColor(ST77XX_YELLOW, ST77XX_BLACK);
  lcd.print("Press Button");

  // Encoder
  //encoder.areEncoderPinsPulldownforEsp32 = false;
  encoder.begin();
  encoder.setup(readEncoderISR);
  bool circleValues =false;
  encoder.setBoundaries(0, 300, circleValues); //minValue, maxValue, circleValues true|false (when max go to min and vice versa)
  //encoder.disableAcceleration(); //acceleration is now enabled by default - disable if you dont need it
	encoder.setAcceleration(100); //or set the value - larger number = more accelearation; 0 or 1 means disabled acceleration
  encoder.setEncoderValue(encoderCounter);

  windowStartTime = millis();
  // Espero por pulsación de tecla para comenzar
  do{ 
    if (millis() > windowStartTime){
      Input1 = thermocouple1.readCelsius();
      Input2 = thermocouple2.readCelsius();
      #ifdef ALPHA
      InputFiltered1 = (ALPHA*Input1) + ((1-ALPHA)*InputFiltered1);
      Input1 = InputFiltered1;
      InputFiltered2 = (ALPHA*Input2) + ((1-ALPHA)*InputFiltered2);
      Input2 = InputFiltered2;
      #endif

      windowStartTime = millis() + WindowSize;
    }
  }while(!encoder.isEncoderButtonClicked());

  lcd.setTextSize(MIDLE_TEXT);
  lcd.fillScreen(ST77XX_BLACK);
  lcd.setCursor(0*6*MIDLE_TEXT, 0*8*MIDLE_TEXT);
  lcd.print("Heater    Out");
  lcd.setCursor(0*6*MIDLE_TEXT, 2*8*MIDLE_TEXT);
  lcd.print("Board  Pulsos");
  lcd.setCursor(3*6*MIDLE_TEXT, 4*8*MIDLE_TEXT);
  lcd.print("Setpoint");
  lcd.setTextColor(ST77XX_WHITE, ST77XX_BLACK);
  oldEncoderCounter=-1;

  attachInterrupt(digitalPinToInterrupt(ZC_PIN), zc_isr,RISING);
  nextTime=millis() + WINDOW_1Seg;

  perfil_temp[0] = Input1;
  perfil_time[0] = startTime/1000;

  t1=perfil_time[0]+perfil_time[1];  // 120
  t2=t1+perfil_time[2];              // 120+60=180
  t3=t2+perfil_time[3];              // 120+60+15=195
  t4=t3+perfil_time[4];              // 120+60+15+15=210
  t5=t4+perfil_time[5];              // 120+60+15+15+150=360
  
  rampt0t1=((perfil_temp[1]-perfil_temp[0])/perfil_time[1]);
  rampt1t2=((perfil_temp[2]-perfil_temp[1])/perfil_time[2]);
  rampt2t3=((perfil_temp[3]-perfil_temp[2])/perfil_time[3]);
  rampt3t4=((perfil_temp[4]-perfil_temp[3])/perfil_time[4]);
  rampt4t5=((perfil_temp[5]-perfil_temp[4])/perfil_time[5]);

  /*Serial.printf("%d %d %d %d %d\n",t1,t2,t3,t4,t5);
  Serial.printf("%.2f %.2f %.2f %.2f %.2f\n", rampt0t1, rampt1t2, rampt2t3, rampt3t4, rampt4t5);*/
  
  windowStartTime = millis();
  //DEBUG
  #ifdef DEBUG
  Serial.begin(9600);
  startTime = windowStartTime;
  #endif
}

// the loop function runs over and over again forever
void loop() {
  //Senso la temperatura cada 200mSeg (frecuencia máxima a la que lee el sensor max6675)
  if (millis() > windowStartTime){
    Input1 = thermocouple1.readCelsius();
    Input2 = thermocouple2.readCelsius();
    #ifdef ALPHA
    InputFiltered1 = (ALPHA*Input1) + ((1-ALPHA)*InputFiltered1);
    Input1 = InputFiltered1;
    InputFiltered2 = (ALPHA*Input2) + ((1-ALPHA)*InputFiltered2);
    Input2 = InputFiltered2;
    #endif

    // DEBUG
    #ifdef DEBUG
    //double Time = (millis()-startTime)/1000.0;
    //Serial.print(Input1);
    //Serial.print(" ");
    //Serial.println(0);
    #ifdef ALPHA
    //Serial.printf("$%.2f %.2f %.2f;",Input1,InputFiltered1,Output1);
    #else
    //Serial.printf("$%.2f %.2f;",Input1,Output1);
    #endif
    #endif

    windowStartTime = millis() + WindowSize;
  }

  myPID.Compute();

  /***************************** CONTROL DE FASE ****************************/
  pulseDelayTransformed = acos(1-Output1/90.0)*(180.0/M_PI); // Para obtener la proporción correcta de la superficie del semiciclo
                                                             // La superficie del SENO no cambia linealmente con el angulo
  pulseDelay = t10mSEG-(uint64_t)map(pulseDelayTransformed, 0, ZC_MAX_ANGLE, ZC_MAX_ANGLE, t10mSEG-ZC_PULSE_WIDTH/2);

  // Filtro para falsos positivos
  #ifdef ZC_INTERRUPT_FILTER
  if(millis()>zcNextTime && zcFlag){
    zcFlag = false;
    zcCounter++;
  }
  #endif

  // Se envía pulso de habilitación del TRIAC
  if(micros()>pulseOn && pulseFlag){
    pulseOff = micros() + G_PULSE_WIDTH ;
    pulseStatus = HIGH;
    pulseFlag = false;
    if(pulseDelay<(t10mSEG-ZC_PULSE_WIDTH/2-G_PULSE_WIDTH))    // Envía pulso solo si Output >0
      digitalWrite(RELAY_PIN, pulseStatus);
  }
  if(micros()>pulseOff && !pulseFlag && pulseStatus){
    pulseStatus = LOW;
    if(pulseDelay>ZC_PULSE_WIDTH/2)
      digitalWrite(RELAY_PIN, pulseStatus);   // Baja pulso solo si Output <180
  }
  /*************************************************************************/

  if(millis()>nextTime){  // Una vez por segundo

    // Perfil térmico *********************************************************
    tiempo =(uint16_t)((millis()-startTime)/1000);
    // Trazado del perfil ideal
    if     (tiempo < t1)
        perfilRamp = rampt0t1*(tiempo-perfil_time[0])+perfil_temp[0];
    else if(tiempo < t2)
        perfilRamp = rampt1t2*(tiempo-t1)+perfil_temp[1];
    else if(tiempo < t3)
        perfilRamp = rampt2t3*(tiempo-t2)+perfil_temp[2];
    else if(tiempo < t4)
        perfilRamp = rampt3t4*(tiempo-t3)+perfil_temp[3];
    else if(tiempo < t5)
        perfilRamp = rampt4t5*(tiempo-t4)+perfil_temp[4];
    else
        perfilRamp = 0;
    
    /*Setpoint1 =  perfilRamp;*/
    switch (etapa)
    {
      case 1: // precalentamiento
        //myPID.SetTunings(0.5, 0.0038989, 9.2996);
        myPID.SetTunings(0.2950, 0.002774, 6.0934);
        //myPID.SetTunings(0.250, 0.001949, 4.19498);
        Setpoint1 = perfil_temp[1]+75;
        if(Input1>=(perfil_temp[1]-10)){
          time34Init = millis();
          etapa = 2;
        }
        break;
      case 2: // activación de flux
        //myPID.SetTunings(1, 0.007798, 18.5991);
        //myPID.SetTunings(0.5, 0.0038989, 9.2996);
        //myPID.SetTunings(0.2950, 0.0023, 5.4877);
        myPID.SetTunings(0.250, 0.001949, 4.19498);
        Setpoint1 = perfil_temp[2]+30;
        if((Input1>=perfil_temp[2]) && (millis()>(time34Init+perfil_time[2]*1000))){
          time34Init = millis();
          etapa = 3;
        }
        break;
      case 3: // reflow
        //myPID.SetTunings(1, 0.007798, 18.5991);
        //myPID.SetTunings(0.5, 0.0038989, 9.2996);
        myPID.SetTunings(0.2950, 0.0023, 5.4877);
        Setpoint1 = perfil_temp[3]+105;
        if((Input1>=(perfil_temp[3]-30)) && (millis()>(time34Init+perfil_time[3]*1000))){
          time34Init = millis();
          etapa = 4;
        }
        break;
      case 4: // extracción
        //myPID.SetTunings(1, 0.007798, 18.5991);
        //myPID.SetTunings(0.5, 0.0038989, 9.2996);
        myPID.SetTunings(0.2950, 0.0023, 5.4877);
        Setpoint1 = perfil_temp[4];
        if(millis()>(time34Init+perfil_time[4]*1000))
          etapa = 5;
        break;
      case 5: // enfriamiento
        Setpoint1 = perfil_temp[5];
        break;
      default:
        break;
    }
    //*************************************************************************

    if(oldInput1!=Input1 || oldInput2!=Input2){
      lcd.setCursor(0*6*MIDLE_TEXT, 1*8*MIDLE_TEXT);
      lcd.printf("%3d",(uint16_t)Input1);
      lcd.setCursor(0*6*MIDLE_TEXT, 3*8*MIDLE_TEXT);
      lcd.printf("%3d",(uint16_t)Input2);

      oldInput1 = Input1;
      oldInput2 = Input2;
    }
    lcd.setCursor(9*6*MIDLE_TEXT, 1*8*MIDLE_TEXT);
    lcd.printf("%4d",(uint8_t)Output1);
    lcd.setCursor(10*6*MIDLE_TEXT, 3*8*MIDLE_TEXT);
    lcd.printf("%3d",zcCounter);

    lcd.setCursor(2*6*BIG_TEXT, 3*7*BIG_TEXT);
    lcd.setTextSize(BIG_TEXT);
    lcd.printf("%3d", (uint16_t)perfil_temp[etapa]);
    lcd.setTextSize(MIDLE_TEXT);

    // DEBUG
    #ifdef DEBUG
    //Time = (millis()-startTime)/1000.0;
    Serial.printf("$%.2f %.2f %d %.2f;",Input1, Input2, etapa, perfilRamp);
    #endif

    zcCounter=0;
    nextTime=millis() + WINDOW_1Seg;      
  }
}
